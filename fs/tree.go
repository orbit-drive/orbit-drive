package fs

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"sync"
)

const (
	// leveldb key to store the root tree
	ROOT_KEY string = "ROOT_TREE"

	// File type constants
	FileCode = iota
	DirCode  = iota
)

var (
	// VTree is the root pointer to the virtual tree of the file
	// structure being synchronized.
	VTree *VNode
)

// VNode represents a file structure where each node can be (i) a dir (ii) a file.
// If is a file, Source links to the ipfs hash saved on the network.
type VNode struct {
	// Id is generated from the absolute path and refers to the key used to save to leveldb.
	Id []byte `json:_id`

	// Path holds the absolute path in the os file system <- Need to compress to relative path.
	Path string `json:path`

	// Type represents if the vnode is a file or dir.
	Type int `json:'type'`

	// Links refers all children vnode in the dir.
	Links []*VNode `json:links`

	// Source refers to the ipfs hash generated by the network.
	Source string `json:source`
}

func (vn *VNode) SetAsDir() {
	vn.Type = DirCode
}

func (vn *VNode) SetAsFile() {
	vn.Type = FileCode
}

// SetSource set the vnode source to the cached source if present.
func (vn *VNode) SetSource(s FileStore) {
	i := ToStr(vn.Id)
	if src, ok := s[i]; ok {
		vn.Source = src
		delete(s, i)
	}
}

// InitVTree initialize a new virtual tree (VTree) given an absolute path.
func InitVTree(path string, s FileStore) error {
	VTree = &VNode{
		Id:     ToByte(ROOT_KEY),
		Path:   path, // To optimize here -> start with "/" not abs path
		Type:   DirCode,
		Links:  []*VNode{},
		Source: "",
	}

	err := VTree.PopulateNodes(s)
	if err != nil {
		return err
	}
	return nil
}

// NewFile traverse VTree to locate path parent dir and
// add a new vnode.
func NewFile(path string) error {
	dir := filepath.Dir(path)
	vn, err := VTree.FindNodeAt(dir)
	if err != nil {
		return err
	}
	n := vn.NewVNode(path)
	fi, err := os.Stat(path)
	if err != nil {
		return err
	}
	if fi.IsDir() {
		n.SetAsDir()
		n.PopulateNodes(FileStore{})
	} else {
		n.SetAsFile()
		n.Save()
	}
	return nil
}

// NewVNode initialize and returns a new VNode under current vnode.
func (vn *VNode) NewVNode(path string) *VNode {
	i := append(vn.Id, path...)
	n := &VNode{
		Id:     HashStr(ToStr(i)),
		Path:   path,
		Links:  []*VNode{},
		Source: "",
	}
	vn.Links = append(vn.Links, n)
	return n
}

// PopulateNodes read a path and populate the its links given
// the path is a directory else creates a file node.
func (vn *VNode) PopulateNodes(s FileStore) error {
	files, err := ioutil.ReadDir(vn.Path)
	if err != nil {
		return err
	}

	var wg sync.WaitGroup
	for _, f := range files {
		abspath := vn.Path + "/" + f.Name()
		n := vn.NewVNode(abspath)
		n.SetSource(s)

		if f.IsDir() {
			n.SetAsDir()
			n.PopulateNodes(s)
		} else {
			n.SetAsFile()
			wg.Add(1)
			go func() {
				err := n.Save()
				if err != nil {
					// To write to a log file.
					fmt.Println(err)
				}
				wg.Done()
			}()
		}
	}

	wg.Wait()
	return nil
}

// Save
func (vn *VNode) Save() error {
	// If ipfs hash not present, then upload to network
	if vn.Source == "" {
		s, err := UploadFile(vn.Path)
		if err != nil {
			fmt.Println(err)
			return err
		}
		vn.Source = s
	}
	return Db.Put(vn.Id, ToByte(vn.Source), nil)
}

// AddNode traverse a VTree to the given path and calls PopulateNodes.
func (vn *VNode) FindNodeAt(path string) (*VNode, error) {
	// Implement find node here, currently just returns the root

	return vn, nil
}

// RemoveNode traverse a VTree and remove the VNode at the given path.
func (vn *VNode) RemoveNode(path string) error {
	return nil
}
