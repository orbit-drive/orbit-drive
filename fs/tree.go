package fs

import (
	"fmt"
	"io/ioutil"
	"sync"
)

const (
	// leveldb key to store the root tree
	ROOT_KEY string = "ROOT_TREE"

	// File type constants
	FileCode = iota
	DirCode  = iota
)

var (
	// VTree is the root pointer to the virtual tree of the file
	// structure being synchronized.
	VTree *VNode
)

// VNode represents a file structure where each node can be (i) a dir (ii) a file.
// If is a file, Source links to the ipfs hash saved on the network.
type VNode struct {
	// Id is generated from the absolute path and refers to the key used to save to leveldb.
	Id []byte `json:_id`

	// Path holds the absolute path in the os file system <- Need to compress to relative path.
	Path string `json:path`

	// Type represents if the vnode is a file or dir.
	Type int `json:'type'`

	// Links refers all children vnode in the dir.
	Links []*VNode `json:links`

	// Source refers to the ipfs hash generated by the network.
	Source string `json:source`
}

// NewVNode initialize and returns a new VNode.
func NewVNode(p string) *VNode {
	return &VNode{
		Id:     HashStr(p),
		Path:   p,
		Links:  []*VNode{},
		Source: "",
	}
}

// InitVTree initialize a new virtual tree (VTree) given an absolute path.
func InitVTree(path string) error {
	VTree = &VNode{
		Id:    ToByte(ROOT_KEY),
		Path:  path,
		Type:  DirCode,
		Links: []*VNode{},
	}

	err := VTree.PopulateNodes(path)
	if err != nil {
		return err
	}
	return nil
}

// PopulateNodes read a path and populate the its links given
// the path is a directory else creates a file node.
func (vn *VNode) PopulateNodes(path string) error {
	files, err := ioutil.ReadDir(path)
	if err != nil {
		return err
	}

	var wg sync.WaitGroup
	for _, f := range files {
		abspath := vn.Path + "/" + f.Name()
		n := NewVNode(abspath)

		vn.Links = append(vn.Links, n)

		if f.IsDir() {
			n.PopulateNodes(abspath)
		} else {
			wg.Add(1)
			go func() {
				err := n.Save()
				if err != nil {
					// To write to a log file.
					fmt.Println(err)
				}
				wg.Done()
			}()
		}
	}

	wg.Wait()
	return nil
}

// Save
func (vn *VNode) Save() error {
	// If ipfs hash not present, then upload to network
	if vn.Source == "" {
		s, err := UploadFile(vn.Path)
		if err != nil {
			fmt.Println(err)
			return err
		}
		vn.Source = s
	}
	_id := ToStr(vn.Id)
	savedHash := SavedFiles[_id]
	if savedHash != "" {
		// run ipfs hash compare here
		// if same just delete from SavedFiles
		// else upload first then delete
		delete(SavedFiles, _id)
	}
	return Db.Put(vn.Id, ToByte(vn.Source), nil)
}

// AddNode traverse a VTree to the given path and calls PopulateNodes.
func (vn *VNode) AddNode(path string) error {
	return nil
}

// RemoveNode traverse a VTree and remove the VNode at the given path.
func (vn *VNode) RemoveNode(path string) error {
	return nil
}
